#include <boost/test/unit_test.hpp>
#include <boost/program_options.hpp>

#include <hive/utilities/database_configuration.hpp>

#include <hive/chain/hive_objects.hpp>
#include <hive/chain/dhf_objects.hpp>
#include <hive/chain/util/delayed_voting.hpp>

#include <hive/plugins/chain/chain_plugin.hpp>
#include <hive/plugins/webserver/webserver_plugin.hpp>
#include <hive/plugins/witness/witness_plugin.hpp>

#include <hive/chain/smt_objects/nai_pool_object.hpp>

#include <fc/crypto/digest.hpp>
#include <fc/smart_ref_impl.hpp>

#include <iostream>
#include <iomanip>
#include <sstream>

#include "database_fixture.hpp"

//using namespace hive::chain::test;

uint32_t HIVE_TESTING_GENESIS_TIMESTAMP = 1431700000;

using namespace hive::plugins::webserver;
using namespace hive::plugins::database_api;
using namespace hive::plugins::block_api;

namespace hive { namespace chain {

using std::cout;
using std::cerr;

autoscope set_mainnet_cashout_values( bool auto_reset )
{
  configuration_data.set_cashout_related_values(
    0, 60 * 60 * 24, 60 * 60 * 24 * 2, 60 * 60 * 24 * 7, 60 * 60 * 12 );
  if( auto_reset )
    return autoscope([](){ configuration_data.reset_cashout_values(); });
  else
    return autoscope([](){});
}

autoscope set_mainnet_feed_values( bool auto_reset )
{
  configuration_data.set_feed_related_values( 60*60/3, 60*60*24*7 );
  if( auto_reset )
    return autoscope([](){ configuration_data.reset_feed_values(); });
  else
    return autoscope([](){});
}

fc::path common_init( const std::function< void( appbase::application& app, int argc, char** argv ) >& app_initializer )
{
  int argc = boost::unit_test::framework::master_test_suite().argc;
  char** argv = boost::unit_test::framework::master_test_suite().argv;
  std::vector<const char*> argv_ext( argv, argv + argc );
  argv_ext.emplace_back( nullptr );

  bool has_data_dir = false;
  fc::path _data_dir;
  std::string temp_data_dir;
  for( int i = 1; i < argc; i++ )
  {
    const std::string arg = argv_ext[ i ];
    if( arg == "--record-assert-trip" )
      fc::enable_record_assert_trip = true;
    if( arg == "--show-test-names" )
      std::cout << "running test " << boost::unit_test::framework::current_test_case().p_name << std::endl;
    if( ( arg == "--data-dir" || arg == "-d" ) && ( i + 1 ) < argc )
    {
      _data_dir = argv_ext[ i + 1 ];
      has_data_dir = true;
    }
  }
  if( has_data_dir == false )
  {
    _data_dir = hive::utilities::temp_directory_path();
    temp_data_dir = _data_dir.string();
    argv_ext.back() = "--data-dir";
    argv_ext.emplace_back( temp_data_dir.c_str() );
    argv_ext.emplace_back( nullptr );
    argc += 2;
  }
  // make sure there is no "trash" config generated by previous test that was interrupted
  remove( ( temp_data_dir + "/config.ini" ).c_str() );
  // ditto with logs directory
  fc::remove_all( ( temp_data_dir + "/logs" ).c_str() );
  // and blockchain directory (including shared memory file)
  fc::remove_all( ( temp_data_dir + "/blockchain" ).c_str() );

  app_initializer( appbase::app(), argc, (char**)argv_ext.data() );
  return _data_dir;
}

fc::ecc::private_key database_fixture::generate_private_key(string seed)
{
  static const fc::ecc::private_key committee = fc::ecc::private_key::regenerate( fc::sha256::hash( string( "init_key" ) ) );
  if( seed == "init_key" )
    return committee;
  return fc::ecc::private_key::regenerate( fc::sha256::hash( seed ) );
}

#ifdef HIVE_ENABLE_SMT
asset_symbol_type database_fixture::get_new_smt_symbol( uint8_t token_decimal_places, chain::database* db )
{
  // The list of available nais is not dependent on SMT desired precision (token_decimal_places).
  static std::vector< asset_symbol_type >::size_type next_nai = 0;
  auto available_nais = db->get< nai_pool_object >().pool();
  FC_ASSERT( available_nais.size() > 0, "No available nai returned by get_nai_pool." );
  const asset_symbol_type& new_nai = available_nais[ next_nai++ % available_nais.size() ];
  // Note that token's precision is needed now, when creating actual symbol.
  return asset_symbol_type::from_nai( new_nai.to_nai(), token_decimal_places );
}
#endif

void database_fixture::generate_block(uint32_t skip, const fc::ecc::private_key& key, int miss_blocks)
{
  skip |= default_skip;
  db_plugin->debug_generate_blocks( key.key_to_wif(), 1, skip, miss_blocks, true );
}

uint32_t database_fixture::generate_blocks(const std::string& debug_key, uint32_t count, uint32_t skip)
{
  return db_plugin->debug_generate_blocks(debug_key, count, skip, 0, true);
}

uint32_t database_fixture::generate_blocks_until(const std::string& debug_key, const fc::time_point_sec& head_block_time,
  bool generate_sparsely, uint32_t skip)
  {
  return db_plugin->debug_generate_blocks_until(debug_key, head_block_time, generate_sparsely, skip, true);
  }

void database_fixture::generate_blocks( uint32_t block_count )
{
  auto produced = db_plugin->debug_generate_blocks( debug_key, block_count, default_skip, 0, true );
  BOOST_REQUIRE( produced == block_count );
}

void database_fixture::generate_blocks(fc::time_point_sec timestamp, bool miss_intermediate_blocks)
{
  db_plugin->debug_generate_blocks_until( debug_key, timestamp, miss_intermediate_blocks, default_skip, true );
  BOOST_REQUIRE( ( db->head_block_time() - timestamp ).to_seconds() < HIVE_BLOCK_INTERVAL );
}

void database_fixture::generate_seconds_blocks( uint32_t seconds, bool skip_interm_blocks )
{
  fc::time_point_sec timestamp = db->head_block_time();
  timestamp += fc::seconds(seconds);
  generate_blocks( timestamp, skip_interm_blocks );
}

void database_fixture::generate_days_blocks( uint32_t days, bool skip_interm_blocks )
{
  generate_seconds_blocks( days * 24 * 3600, skip_interm_blocks );
}

void database_fixture::generate_until_block( uint32_t block_num )
{
  while( db->head_block_num() < block_num )
    generate_block();
}

void database_fixture::generate_until_irreversible_block( uint32_t block_num )
{
  while( db->get_last_irreversible_block_num() < block_num )
    generate_block();
}

uint32_t database_fixture::get_last_irreversible_block_num()
{
  return db->get_last_irreversible_block_num();
}

fc::string database_fixture::get_current_time_iso_string() const
{
  fc::time_point_sec current_time = db->head_block_time();
  return current_time.to_iso_string();
}

const account_object& database_fixture::account_create(
  const string& name,
  const string& creator,
  const private_key_type& creator_key,
  const share_type& fee,
  const public_key_type& key,
  const public_key_type& post_key,
  const string& json_metadata
  )
{
  try
  {
    auto actual_fee = std::min( fee, db->get_witness_schedule_object().median_props.account_creation_fee.amount );
    auto fee_remainder = fee - actual_fee;

    account_create_operation op;
    op.new_account_name = name;
    op.creator = creator;
    op.fee = asset( actual_fee, HIVE_SYMBOL );
    op.owner = authority( 1, key, 1 );
    op.active = authority( 1, key, 1 );
    op.posting = authority( 1, post_key, 1 );
    op.memo_key = key;
    op.json_metadata = json_metadata;

    trx.operations.push_back( op );

    trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
    trx.validate();
    push_transaction( trx, creator_key );
    trx.clear();

    if( fee_remainder > 0 )
    {
      vest( HIVE_INIT_MINER_NAME, name, asset( fee_remainder, HIVE_SYMBOL ) );
    }

    const account_object& acct = db->get_account( name );

    return acct;
  }
  FC_CAPTURE_AND_RETHROW( (name)(creator) )
}

const account_object& database_fixture::account_create(
  const string& name,
  const public_key_type& key,
  const public_key_type& post_key
)
{
  try
  {
    return account_create(
      name,
      HIVE_INIT_MINER_NAME,
      init_account_priv_key,
      std::max( db->get_witness_schedule_object().median_props.account_creation_fee.amount * HIVE_CREATE_ACCOUNT_WITH_HIVE_MODIFIER, share_type( 100 ) ),
      key,
      post_key,
      "" );
  }
  FC_CAPTURE_AND_RETHROW( (name) );
}

const account_object& database_fixture::account_create_default_fee(
  const string& name,
  const public_key_type& key,
  const public_key_type& post_key
)
{
  try
  {
    return account_create(
      name,
      HIVE_INIT_MINER_NAME,
      init_account_priv_key,
      db->get_witness_schedule_object().median_props.account_creation_fee.amount,
      key,
      post_key,
      "" );
  }
  FC_CAPTURE_AND_RETHROW( (name) );
}

const account_object& database_fixture::account_create(
  const string& name,
  const public_key_type& key
)
{
  return account_create( name, key, key );
}

const witness_object& database_fixture::witness_create(
  const string& owner,
  const private_key_type& owner_key,
  const string& url,
  const public_key_type& signing_key,
  const share_type& fee )
{
  try
  {
    witness_update_operation op;
    op.owner = owner;
    op.url = url;
    op.block_signing_key = signing_key;
    op.fee = asset( fee, HIVE_SYMBOL );

    trx.operations.push_back( op );
    trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
    trx.validate();
    push_transaction( trx, owner_key );
    trx.clear();

    return db->get_witness( owner );
  }
  FC_CAPTURE_AND_RETHROW( (owner)(url) )
}

void database_fixture::account_update( const string& account, const fc::ecc::public_key& memo_key, const string& metadata,
  optional<authority> owner, optional<authority> active, optional<authority> posting, const fc::ecc::private_key& key )
{
  account_update_operation op;
  op.account = account;
  op.owner = owner;
  op.active = active;
  op.posting = posting;
  op.memo_key = memo_key;
  op.json_metadata = metadata;

  push_transaction( op, key );
}

void database_fixture::account_update2( const string& account,
  optional<authority> owner, optional<authority> active, optional<authority> posting,
  optional<public_key_type> memo_key, const string& metadata, const string& posting_metadata, const fc::ecc::private_key& key )
{
  account_update2_operation op;
  op.account = account;
  op.owner = owner;
  op.active = active;
  op.posting = posting;
  op.memo_key = memo_key;
  op.json_metadata = metadata;
  op.posting_json_metadata = posting_metadata;

  push_transaction( op, key );
}

void database_fixture::witness_feed_publish(
  const string& publisher,
  const price& exchange_rate,
  const private_key_type& key )
{
  feed_publish_operation op;
  op.publisher = publisher;
  op.exchange_rate = exchange_rate;

  push_transaction( op, key );
}

void database_fixture::witness_vote( account_name_type voter, account_name_type witness, const fc::ecc::private_key& key, bool approve )
{
  signed_transaction tx;
  account_witness_vote_operation op;
  op.account = voter;
  op.witness = witness;
  op.approve = approve;

  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  tx.operations.push_back( op );
  push_transaction( tx, key );
}

void database_fixture::fund(
  const string& account_name,
  const share_type& amount
  )
{
  try
  {
    transfer( HIVE_INIT_MINER_NAME, account_name, asset( amount, HIVE_SYMBOL ) );

  } FC_CAPTURE_AND_RETHROW( (account_name)(amount) )
}

void database_fixture::fund(
  const string& account_name,
  const asset& amount,
  bool update_print_rate
  )
{
  try
  {
    db_plugin->debug_update( [=]( database& db)
    {
      if( amount.symbol.space() == asset_symbol_type::smt_nai_space )
      {
        db.adjust_balance(account_name, amount);
        db.adjust_supply(amount);
        // Note that SMT have no equivalent of HBD, hence no virtual supply, hence no need to update it.
        return;
      }

      const auto& median_feed = db.get_feed_history();
      if( amount.symbol == HBD_SYMBOL )
      {
        if( median_feed.current_median_history.is_null() )
          db.modify( median_feed, [&]( feed_history_object& f )
        {
          f.current_median_history = price( asset( 1, HBD_SYMBOL ), asset( 1, HIVE_SYMBOL ) );
          f.market_median_history = f.current_median_history;
          f.current_min_history = f.current_median_history;
          f.current_max_history = f.current_median_history;
        } );
      }

      db.modify( db.get_account( account_name ), [&]( account_object& a )
      {
        if( amount.symbol == HIVE_SYMBOL )
          a.balance += amount;
        else if( amount.symbol == HBD_SYMBOL )
        {
          a.hbd_balance += amount;
          a.hbd_seconds_last_update = db.head_block_time();
        }
      });

      db.modify( db.get_dynamic_global_properties(), [&]( dynamic_global_property_object& gpo )
      {
        if( amount.symbol == HIVE_SYMBOL )
          gpo.current_supply += amount;
        else if( amount.symbol == HBD_SYMBOL )
        {
          gpo.current_hbd_supply += amount;
          gpo.virtual_supply = gpo.current_supply + gpo.current_hbd_supply * median_feed.current_median_history;
        }
      });

      if( update_print_rate )
        db.update_virtual_supply();
    }, default_skip );
  }
  FC_CAPTURE_AND_RETHROW( (account_name)(amount) )
}

void database_fixture::convert(
  const string& account_name,
  const asset& amount )
{
  try
  {
    if ( amount.symbol == HIVE_SYMBOL )
    {
      db->adjust_balance( account_name, -amount );
      db->adjust_balance( account_name, db->to_hbd( amount ) );
      db->adjust_supply( -amount );
      db->adjust_supply( db->to_hbd( amount ) );
    }
    else if ( amount.symbol == HBD_SYMBOL )
    {
      db->adjust_balance( account_name, -amount );
      db->adjust_balance( account_name, db->to_hive( amount ) );
      db->adjust_supply( -amount );
      db->adjust_supply( db->to_hive( amount ) );
    }
  } FC_CAPTURE_AND_RETHROW( (account_name)(amount) )
}

void database_fixture::convert_hbd_to_hive( const std::string& owner, uint32_t requestid, const asset& amount, 
  const fc::ecc::private_key& key )
{
  convert_operation op;
  op.owner = owner;
  op.requestid = requestid;
  op.amount = amount;
  
  push_transaction( op, key );
}

void database_fixture::collateralized_convert_hive_to_hbd( const std::string& owner, uint32_t requestid, const asset& amount, 
  const fc::ecc::private_key& key )
{
    collateralized_convert_operation op;
    op.owner = owner;
    op.requestid = requestid;
    op.amount = amount;

    push_transaction( op, key );
}

void database_fixture::transfer(
  const string& from,
  const string& to,
  const asset& amount )
{
  try
  {
    transfer_operation op;
    op.from = from;
    op.to = to;
    op.amount = amount;

    trx.operations.push_back( op );
    trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
    trx.validate();

    push_transaction( trx, ( from == HIVE_INIT_MINER_NAME ) ? init_account_priv_key : fc::ecc::private_key(), ~0 );
    trx.clear();
  } FC_CAPTURE_AND_RETHROW( (from)(to)(amount) )
}

void database_fixture::transfer( const string& from, const string& to, const asset& amount, const std::string& memo,
  const fc::ecc::private_key& key )
{
  transfer_operation op;
  op.from = from;
  op.to = to;
  op.amount = amount;
  op.memo = memo;

  push_transaction( op, key );
}

void database_fixture::recurrent_transfer( const string& from, const string& to, const asset& amount, const string& memo,
  uint16_t recurrence, uint16_t executions, const fc::ecc::private_key& key )
{
  recurrent_transfer_operation op;
  op.from = from;
  op.to = to;
  op.amount = amount;
  op.memo = memo;
  op.recurrence = recurrence;
  op.executions = executions;

  push_transaction( op, key );
}

void database_fixture::push_transaction( const operation& op, const fc::ecc::private_key& key )
{
  signed_transaction tx;
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  tx.operations.push_back( op );
  push_transaction(tx, key, 0);
}

full_transaction_ptr database_fixture::push_transaction( const signed_transaction& tx, const fc::ecc::private_key& key,
  uint32_t skip_flags, hive::protocol::pack_type pack_type, fc::ecc::canonical_signature_type _sig_type )
{
  if( key == fc::ecc::private_key() )
    return push_transaction( tx, std::vector<fc::ecc::private_key>(), skip_flags, pack_type, _sig_type );
  else
    return push_transaction( tx, std::vector<fc::ecc::private_key>{ key }, skip_flags, pack_type, _sig_type );
}

full_transaction_ptr database_fixture::push_transaction( const signed_transaction& tx, const std::vector<fc::ecc::private_key>& keys,
  uint32_t skip_flags, hive::protocol::pack_type pack_type, fc::ecc::canonical_signature_type _sig_type )
{
  full_transaction_ptr _tx = hive::chain::full_transaction_type::create_from_signed_transaction( tx, pack_type, false );
  _tx->sign_transaction( keys, db->get_chain_id(), _sig_type, pack_type );
  db->push_transaction( _tx, skip_flags );
  return _tx;
}

bool database_fixture::push_block( const std::shared_ptr<full_block_type>& b, uint32_t skip_flags /* = 0 */ )
{
  return test::_push_block(*db, b, skip_flags);
}

void database_fixture::vest( const string& from, const string& to, const asset& amount )
{
  try
  {
    FC_ASSERT( amount.symbol == HIVE_SYMBOL, "Can only vest TESTS" );

    transfer_to_vesting_operation op;
    op.from = from;
    op.to = to;
    op.amount = amount;

    trx.operations.push_back( op );
    trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
    trx.validate();

    push_transaction( trx, ( from == HIVE_INIT_MINER_NAME ) ? init_account_priv_key : fc::ecc::private_key(), ~0 );
    trx.clear();
  } FC_CAPTURE_AND_RETHROW( (from)(to)(amount) )
}

void database_fixture::vest( const string& from, const share_type& amount )
{
  try
  {
    transfer_to_vesting_operation op;
    op.from = from;
    op.to = "";
    op.amount = asset( amount, HIVE_SYMBOL );

    trx.operations.push_back( op );
    trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
    trx.validate();

    push_transaction( trx, ( from == HIVE_INIT_MINER_NAME ) ? init_account_priv_key : fc::ecc::private_key(), ~0 );
    trx.clear();
  } FC_CAPTURE_AND_RETHROW( (from)(amount) )
}

void database_fixture::vest( const string& from, const string& to, const asset& amount, const fc::ecc::private_key& key )
{
  transfer_to_vesting_operation op;
  op.from = from;
  op.to = to;
  op.amount = amount;

  push_transaction( op, key );
}

void database_fixture::delegate_vest( const string& delegator, const string& delegatee, const asset& amount, const fc::ecc::private_key& key )
{
  delegate_vesting_shares_operation op;
  op.vesting_shares = amount;
  op.delegator = delegator;
  op.delegatee = delegatee;

  push_transaction( op, key );
}

void database_fixture::set_withdraw_vesting_route( const string& from, const string& to, uint16_t percent, bool auto_vest,
                                                   const fc::ecc::private_key& key )
{
  set_withdraw_vesting_route_operation op;
  op.from_account = from;
  op.to_account = to;
  op.percent = percent;
  op.auto_vest = auto_vest;
  push_transaction( op, key );
}

void database_fixture::withdraw_vesting( const string& account, const asset& amount, const fc::ecc::private_key& key )
{
  withdraw_vesting_operation op;
  op.account = account;
  op.vesting_shares = amount;

  push_transaction( op, key );
}

void database_fixture::proxy( const string& account, const string& proxy )
{
  try
  {
    account_witness_proxy_operation op;
    op.account = account;
    op.proxy = proxy;
    signed_transaction tx;
    tx.operations.push_back( op );
    tx.set_expiration(db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION);
    push_transaction( tx, fc::ecc::private_key(), ~0 );
  } FC_CAPTURE_AND_RETHROW( (account)(proxy) )
}

void database_fixture::set_price_feed( const price& new_price, bool stop_at_update_block )
{
  for( size_t i = 1; i < 8; i++ )
  {
    witness_set_properties_operation op;
    op.owner = HIVE_INIT_MINER_NAME + fc::to_string( i );
    op.props[ "hbd_exchange_rate" ] = fc::raw::pack_to_vector( new_price );
    op.props[ "key" ] = fc::raw::pack_to_vector( init_account_pub_key );

    trx.operations.push_back( op );
    trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
    push_transaction( trx, fc::ecc::private_key(), ~0 );
    trx.clear();
  }

  if( stop_at_update_block )
    generate_blocks( HIVE_FEED_INTERVAL_BLOCKS - ( db->head_block_num() % HIVE_FEED_INTERVAL_BLOCKS ) );
  else
    generate_blocks( HIVE_BLOCKS_PER_HOUR );

  BOOST_REQUIRE(
#ifdef IS_TEST_NET
    !db->skip_price_feed_limit_check ||
#endif
    db->get(feed_history_id_type()).current_median_history == new_price
  );
}

void database_fixture::set_witness_props( const flat_map< string, vector< char > >& props )
{
  trx.clear();
  for( size_t i=0; i<HIVE_MAX_WITNESSES; i++ )
  {
    witness_set_properties_operation op;
    op.owner = HIVE_INIT_MINER_NAME + (i == 0 ? "" : fc::to_string( i ));
    op.props = props;
    if( props.find( "key" ) == props.end() )
      op.props["key"] = fc::raw::pack_to_vector( init_account_pub_key );

    trx.operations.push_back( op );
    trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
    push_transaction( trx, fc::ecc::private_key(), ~0 );
    trx.clear();
  }

  const witness_schedule_object* wso = &(db->get_witness_schedule_object());
  uint32_t old_next_shuffle = wso->next_shuffle_block_num;

  for( size_t i=0; i<2*HIVE_MAX_WITNESSES+1; i++ )
  {
    generate_block();
    wso = &(db->get_witness_schedule_object());
    if( wso->next_shuffle_block_num != old_next_shuffle )
      return;
  }
  FC_ASSERT( false, "Couldn't apply properties in ${n} blocks", ("n", 2*HIVE_MAX_WITNESSES+1) );
}

void database_fixture::limit_order_create( const string& owner, const asset& amount_to_sell, const asset& min_to_receive, bool fill_or_kill,
                                           const fc::microseconds& expiration_shift, uint32_t orderid, const fc::ecc::private_key& key )
{
  limit_order_create_operation op;
  op.owner = owner;
  op.amount_to_sell = amount_to_sell;
  op.min_to_receive = min_to_receive;
  op.fill_or_kill = fill_or_kill;
  op.expiration = db->head_block_time() + expiration_shift;
  op.orderid = orderid;

  signed_transaction tx;
  tx.operations.clear();
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  tx.operations.push_back( op );
  push_transaction( tx, key );
}

void database_fixture::limit_order_cancel( const string& owner, uint32_t orderid, const fc::ecc::private_key& key )
{
  limit_order_cancel_operation op;
  op.owner = owner;
  op.orderid = orderid;

  signed_transaction tx;
  tx.operations.clear();
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  tx.operations.push_back( op );
  push_transaction( tx, key );
}

void database_fixture::limit_order2_create( const string& owner, const asset& amount_to_sell, const price& exchange_rate, bool fill_or_kill,
                                            const fc::microseconds& expiration_shift, uint32_t orderid, const fc::ecc::private_key& key )
{
  limit_order_create2_operation op;
  op.owner = owner;
  op.orderid = orderid;
  op.amount_to_sell = amount_to_sell;
  op.exchange_rate = exchange_rate;
  op.fill_or_kill = fill_or_kill;
  op.expiration = db->head_block_time() + expiration_shift;

  signed_transaction tx;
  tx.operations.clear();
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  tx.operations.push_back( op );
  push_transaction( tx, key );
}

void database_fixture::escrow_transfer( const string& from, const string& to, const string& agent, const asset& hive_amount, 
  const asset& hbd_amount, const asset& fee, const std::string& json_meta, const fc::microseconds& ratification_shift,
  const fc::microseconds& expiration_shift, uint32_t escrow_id, const fc::ecc::private_key& key )
{
  escrow_transfer_operation op;
  op.from = from;
  op.to = to;
  op.agent = agent;
  op.hive_amount = hive_amount;
  op.hbd_amount = hbd_amount;
  op.fee = fee;
  op.json_meta = json_meta;
  op.ratification_deadline = db->head_block_time() + ratification_shift;
  op.escrow_expiration = db->head_block_time() + expiration_shift;
  op.escrow_id = escrow_id;

  signed_transaction tx;
  tx.operations.push_back( op );
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( tx, key );
}

void database_fixture::escrow_approve( const string& from, const string& to, const string& agent, const string& who, bool approve, uint32_t escrow_id,
                                       const fc::ecc::private_key& key )
{
  escrow_approve_operation op;
  op.from = from;
  op.to = to;
  op.agent = agent;
  op.who = who;
  op.approve = approve;
  op.escrow_id = escrow_id;

  signed_transaction tx;
  tx.operations.push_back( op );
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( tx, key );
}

void database_fixture::escrow_release( const string& from, const string& to, const string& agent, const string& who,
                                       const string& receiver, const asset& hive_amount, const asset& hbd_amount,
                                       uint32_t escrow_id, const fc::ecc::private_key& key )
{
  escrow_release_operation op;
  op.from = from;
  op.to = to;
  op.agent = agent;
  op.who = who;
  op.receiver = receiver;
  op.hive_amount = hive_amount;
  op.hbd_amount = hbd_amount;
  op.escrow_id = escrow_id;

  signed_transaction tx;
  tx.operations.push_back( op );
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( tx, key );
}

void database_fixture::escrow_dispute( const string& from, const string& to, const string& agent, const string& who,
                                       uint32_t escrow_id, const fc::ecc::private_key& key )
{
  escrow_dispute_operation op;
  op.from = from;
  op.to = to;
  op.agent = agent;
  op.who = who;
  op.escrow_id = escrow_id;

  signed_transaction tx;
  tx.operations.push_back( op );
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( tx, key );
}

void database_fixture::transfer_to_savings( const string& from, const string& to, const asset& amount, const string& memo,
                                            const fc::ecc::private_key& key )
{
  transfer_to_savings_operation op;
  op.from = from;
  op.to = to;
  op.amount = amount;
  op.memo = memo;

  push_transaction( op, key );
}

void database_fixture::transfer_from_savings( const string& from, const string& to, const asset& amount, const string& memo, uint32_t request_id,
                                              const fc::ecc::private_key& key )
{
  transfer_from_savings_operation op;
  op.from = from;
  op.request_id = request_id;
  op.to = to;
  op.amount = amount;
  op.memo = memo;

  push_transaction( op, key );
}

void database_fixture::cancel_transfer_from_savings( const string& from, uint32_t request_id, const fc::ecc::private_key& key )
{
  cancel_transfer_from_savings_operation op;
  op.from = from;
  op.request_id = request_id;

  push_transaction( op, key );
}

void database_fixture::push_custom_operation( const flat_set< account_name_type >& required_auths, uint16_t id, const vector< char >& data,
  const fc::ecc::private_key& key )
{
  custom_operation op;
  op.required_auths = required_auths;
  op.id = id;
  op.data = data;

  push_transaction( op, key );
}

void database_fixture::push_custom_json_operation( const flat_set< account_name_type >& required_auths,
  const flat_set< account_name_type >& required_posting_auths, const custom_id_type& id, const std::string& json,
  const fc::ecc::private_key& key )
{
  custom_json_operation op;
  op.required_auths = required_auths;
  op.required_posting_auths = required_posting_auths;
  op.id = id;
  op.json = json;

  push_transaction( op, key );
}

int64_t database_fixture::create_proposal( const std::string& creator, const std::string& receiver, const std::string& subject,
  const std::string& permlink, time_point_sec start_date, time_point_sec end_date, asset daily_pay, const fc::ecc::private_key& key )
{
  create_proposal_operation op;

  op.creator = creator;
  op.receiver = receiver;
  op.start_date = start_date;
  op.end_date = end_date;
  op.daily_pay = daily_pay;
  op.subject = subject;
  op.permlink = permlink;

  push_transaction( op, key );

  const auto& proposal_idx = db-> template get_index< proposal_index >().indices(). template get< by_proposal_id >();
  auto itr = proposal_idx.end();
  BOOST_REQUIRE( proposal_idx.begin() != itr );
  --itr;
  BOOST_REQUIRE( creator == itr->creator );

  return itr->proposal_id;
}

int64_t database_fixture::create_proposal( std::string creator, std::string receiver, time_point_sec start_date, time_point_sec end_date,
  asset daily_pay, const fc::ecc::private_key& key, bool with_block_generation )
{
  static uint32_t cnt = 0;

  const std::string permlink = "permlink" + std::to_string( cnt );
  if( with_block_generation )
    post_comment_with_block_generation(creator, permlink, "title", "body", "test", key);
  else
    post_comment(creator, permlink, "title", "body", "test", key);

  int64_t proposal_id = 
    create_proposal( creator, receiver, std::to_string( cnt ) /*subject*/, permlink, start_date, end_date, daily_pay, key );

  //An unique subject is generated by cnt
  ++cnt;

  return proposal_id;
}

void database_fixture::update_proposal(uint64_t proposal_id, std::string creator, asset daily_pay, std::string subject, std::string permlink, const fc::ecc::private_key& key, time_point_sec* end_date)
{
  signed_transaction tx;
  update_proposal_operation op;

  op.proposal_id = proposal_id;
  op.creator = creator;
  op.daily_pay = daily_pay;
  op.subject = subject;
  op.permlink = permlink;

  if (end_date != nullptr) {
    update_proposal_end_date ped;
    ped.end_date = *end_date;
    op.extensions.insert(ped);
  }

  tx.operations.push_back( op );
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( tx, key );
  tx.operations.clear();
}

void database_fixture::vote_proposal( std::string voter, const std::vector< int64_t >& id_proposals, bool approve, const fc::ecc::private_key& key )
{
  update_proposal_votes_operation op;

  op.voter = voter;
  op.proposal_ids.insert(id_proposals.cbegin(), id_proposals.cend());
  op.approve = approve;

  signed_transaction tx;
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  tx.operations.push_back( op );
  push_transaction( tx, key );
}

bool database_fixture::exist_proposal( int64_t id )
{
  const auto& proposal_idx = db->get_index< proposal_index >().indices(). template get< by_proposal_id >();
  return proposal_idx.find( id ) != proposal_idx.end();
}

const proposal_object* database_fixture::find_proposal( int64_t id )
{
  const auto& proposal_idx = db->get_index< proposal_index >().indices(). template get< by_proposal_id >();
  auto found = proposal_idx.find( id );

  if( found != proposal_idx.end() )
    return &(*found);
  else
    return nullptr;
}

void database_fixture::remove_proposal(account_name_type _deleter, flat_set<int64_t> _proposal_id, const fc::ecc::private_key& _key)
{
  remove_proposal_operation rp;
  rp.proposal_owner = _deleter;
  rp.proposal_ids   = _proposal_id;

  signed_transaction trx;
  trx.operations.push_back( rp );
  trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( trx, _key );
  trx.operations.clear();
}

const proposal_vote_object* database_fixture::find_vote_for_proposal(const std::string& _user, int64_t _proposal_id)
{
  const auto& proposal_vote_idx = db->get_index< proposal_vote_index >().indices(). template get< by_voter_proposal >();
  auto found_vote = proposal_vote_idx.find( boost::make_tuple(_user, _proposal_id ) );
  if( found_vote != proposal_vote_idx.end() )
    return &(*found_vote);
  else
    return nullptr;
}

uint64_t database_fixture::get_nr_blocks_until_proposal_maintenance_block()
{
  auto block_time = db->head_block_time();

  auto next_maintenance_time = db->get_dynamic_global_properties().next_maintenance_time;
  auto ret = ( next_maintenance_time - block_time ).to_seconds() / HIVE_BLOCK_INTERVAL;

  FC_ASSERT( next_maintenance_time >= block_time );

  return ret;
}

uint64_t database_fixture::get_nr_blocks_until_daily_proposal_maintenance_block()
{
  auto block_time = db->head_block_time();

  auto next_maintenance_time = db->get_dynamic_global_properties().next_daily_maintenance_time;
  auto ret = ( next_maintenance_time - block_time ).to_seconds() / HIVE_BLOCK_INTERVAL;

  FC_ASSERT( next_maintenance_time >= block_time );

  return ret;
}

account_id_type database_fixture::get_account_id( const string& account_name )const
{
  return db->get_account( account_name ).get_id();
}

asset database_fixture::get_balance( const string& account_name )const
{
  return db->get_account( account_name ).get_balance();
}

asset database_fixture::get_hbd_balance( const string& account_name )const
{
  return db->get_account( account_name ).get_hbd_balance();
}

asset database_fixture::get_savings( const string& account_name )const
{
  return db->get_account( account_name ).get_savings();
}

asset database_fixture::get_hbd_savings( const string& account_name )const
{
  return db->get_account( account_name ).get_hbd_savings();
}

asset database_fixture::get_rewards( const string& account_name )const
{
  return db->get_account( account_name ).get_rewards();
}

asset database_fixture::get_hbd_rewards( const string& account_name )const
{
  return db->get_account( account_name ).get_hbd_rewards();
}

asset database_fixture::get_vesting( const string& account_name )const
{
  return db->get_account( account_name ).get_vesting();
}

asset database_fixture::get_vest_rewards( const string& account_name )const
{
  return db->get_account( account_name ).get_vest_rewards();
}

asset database_fixture::get_vest_rewards_as_hive( const string& account_name )const
{
  return db->get_account( account_name ).get_vest_rewards_as_hive();
}

void database_fixture::post_comment_internal( const std::string& _author, const std::string& _permlink, const std::string& _title, const std::string& _body,
  const std::string& _parent_author, const std::string& _parent_permlink, const fc::ecc::private_key& _key )
{
  comment_operation comment;

  comment.author = _author;
  comment.permlink = _permlink;
  comment.title = _title;
  comment.body = _body;
  comment.parent_author = _parent_author;
  comment.parent_permlink = _parent_permlink;

  push_transaction( comment, _key );
}

void database_fixture::post_comment_with_block_generation( std::string _author, std::string _permlink, std::string _title, std::string _body, std::string _parent_permlink, const fc::ecc::private_key& _key)
{
  generate_blocks( db->head_block_time() + HIVE_MIN_ROOT_COMMENT_INTERVAL + fc::seconds( HIVE_BLOCK_INTERVAL ), true );

  post_comment_internal( _author, _permlink, _title, _body, "", _parent_permlink, _key );
}

void database_fixture::post_comment( std::string _author, std::string _permlink, std::string _title, std::string _body, std::string _parent_permlink, const fc::ecc::private_key& _key)
{
  post_comment_internal( _author, _permlink, _title, _body, "", _parent_permlink, _key );
}

void database_fixture::post_comment_to_comment( const std::string& author, const std::string& permlink, const std::string& title, const std::string& body,
  const std::string& parent_author, const std::string& parent_permlink, const fc::ecc::private_key& key )
{
  post_comment_internal( author, permlink, title, body, parent_author, parent_permlink, key );
}

void database_fixture::delete_comment( std::string _author, std::string _permlink, const fc::ecc::private_key& _key )
{
  delete_comment_operation op;

  op.author = _author;
  op.permlink = _permlink;

  signed_transaction tx;
  tx.operations.push_back( op );
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( tx, _key );
  tx.operations.clear();
}

void database_fixture::set_comment_options( const std::string& author, const std::string& permlink, const asset& max_accepted_payout,
  uint16_t percent_hbd, bool allow_curation_rewards, bool allow_votes, const fc::ecc::private_key& key )
{
  comment_options_extensions_type extensions;
  set_comment_options( author, permlink, max_accepted_payout, percent_hbd, allow_curation_rewards, allow_votes, extensions, key );
}

void database_fixture::set_comment_options( const std::string& author, const std::string& permlink, const asset& max_accepted_payout,
  uint16_t percent_hbd, bool allow_curation_rewards, bool allow_votes, const comment_options_extensions_type& extensions,
  const fc::ecc::private_key& key )
{
  comment_options_operation op;
  op.author = author;
  op.permlink = permlink;
  op.max_accepted_payout = max_accepted_payout;
  op.percent_hbd = percent_hbd;
  op.allow_curation_rewards = allow_curation_rewards;
  op.allow_votes = allow_votes;
  op.extensions = extensions;

  push_transaction( op, key );
}


void database_fixture::vote( std::string _author, std::string _permlink, std::string _voter, int16_t _weight, const fc::ecc::private_key& _key )
{
  vote_operation vote;

  vote.author = _author;
  vote.permlink = _permlink;
  vote.voter = _voter;
  vote.weight = _weight;
 
  signed_transaction trx;
  trx.operations.push_back( vote );
  trx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( trx, _key );
  trx.operations.clear();
}

void database_fixture::claim_reward_balance( const std::string& account, const asset& reward_hive, const asset& reward_hbd,
                                             const asset& reward_vests, const fc::ecc::private_key& key )
{
  claim_reward_balance_operation op;
  op.account = account;
  op.reward_hive = reward_hive;
  op.reward_hbd = reward_hbd;
  op.reward_vests = reward_vests;

  push_transaction( op, key );
}

void database_fixture::create_with_pow( std::string _name, const fc::ecc::public_key& _public_key,
                                       const fc::ecc::private_key& _private_key )
{
  pow_operation op;
  op.worker_account = _name;
  op.block_id = db->head_block_id();
  op.work.worker = _public_key;
  //note: we cannot compute nonce once and hardcode it in the test because HIVE_BLOCKCHAIN_VERSION
  //becomes part of first block as extension, which means when version changes (because we have new
  //hardfork coming or just because of HIVE_ENABLE_SMT) the nonces will have to change as well
  op.nonce = -1;
  do
  {
    ++op.nonce;
    op.work.create( _private_key, op.work_input() );
  }
  while( op.work.work >= db->get_pow_target() );
  //default props

  //pow_operation does not need signature - signing it anyway leads to superfluous signature error
  push_transaction( op, fc::ecc::private_key() );
}

void database_fixture::create_with_pow2( std::string _worker_account, const fc::ecc::public_key& _public_key,
                                         const fc::ecc::private_key& _private_key )
{
  pow2_operation op;
  pow2 pow;
  int nonce = -1;
  do
  {
    ++nonce;
    pow.create( db->head_block_id(), _worker_account, nonce );
  }
  while( pow.pow_summary >= db->get_pow_summary_target() );
  op.work = pow;
  op.new_owner_key = _public_key;
  //default props

  //This time signature is not superfluous (see create_with_pow above);
  //when we set new_owner_key (which we have to for new account) pow2_operation declares needed authority as "other"
  push_transaction( op, _private_key );
}

void database_fixture::create_with_delegation( const std::string& creator, const std::string& new_account_name, 
  const fc::ecc::public_key& public_key, const fc::ecc::private_key& posting_key, const asset& delegation,
  const fc::ecc::private_key& key )
{
  account_create_with_delegation_operation op;
  op.fee = db->get_witness_schedule_object().median_props.account_creation_fee;
  op.delegation = delegation;
  op.creator = creator;
  op.new_account_name = new_account_name;
  op.owner = authority( 1, public_key, 1 );
  op.active = authority( 1, public_key, 1 );
  op.posting = authority( 1, posting_key.get_public_key(), 1 );
  op.memo_key = posting_key.get_public_key();
  op.json_metadata = "";

  push_transaction( op, key );
}

void database_fixture::claim_account( const std::string& creator, const asset& fee, const fc::ecc::private_key& key )
  {
    claim_account_operation claim_account;
    claim_account.creator = creator;
    claim_account.fee = fee;

    push_transaction( claim_account, key );
  }

void database_fixture::create_claimed_account( const std::string& creator, const std::string& new_account_name, 
  const fc::ecc::public_key& public_key, const fc::ecc::public_key& posting_key, const string& json_metadata, 
  const fc::ecc::private_key& key )
{
  create_claimed_account_operation op;
  op.creator = creator;
  op.new_account_name = new_account_name;
  op.owner = authority( 1, public_key, 1 );
  op.active = authority( 1, public_key, 1 );
  op.posting = authority( 1, posting_key, 1 );
  op.memo_key = posting_key;
  op.json_metadata = json_metadata;

  push_transaction( op, key );
}

void database_fixture::change_recovery_account( const std::string& account_to_recover, const std::string& new_recovery_account, 
  const fc::ecc::private_key& key )
{
  change_recovery_account_operation op;
  op.account_to_recover = account_to_recover;
  op.new_recovery_account = new_recovery_account;

  push_transaction( op, key );
}

void database_fixture::request_account_recovery( const std::string& recovery_account, const std::string& account_to_recover,
  const authority& new_owner_authority, const fc::ecc::private_key& key )
{
  request_account_recovery_operation op;
  op.recovery_account = recovery_account;
  op.account_to_recover = account_to_recover;
  op.new_owner_authority = new_owner_authority;

  push_transaction( op, key );
}

void database_fixture::recover_account( const std::string& account_to_recover, const fc::ecc::private_key& new_owner_key,
  const fc::ecc::private_key& recent_owner_key )
{
  recover_account_operation op;
  op.account_to_recover = account_to_recover;
  op.new_owner_authority = authority( 1, new_owner_key.get_public_key(), 1);
  op.recent_owner_authority = authority( 1, recent_owner_key.get_public_key(), 1);;

  signed_transaction tx;
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  tx.operations.push_back( op );
  push_transaction( tx, { recent_owner_key, new_owner_key } );
}

vector< operation > database_fixture::get_last_operations( uint32_t num_ops )
{
  vector< operation > ops;
  const auto& idx = db->get_index< hive::plugins::account_history_rocksdb::volatile_operation_index, by_id >();
  auto it = idx.end();
  while( it != idx.begin() && num_ops > 0 )
  {
    --it;
    --num_ops;
    operation op = fc::raw::unpack_from_buffer< operation >( it->serialized_op );
    ops.emplace_back( std::move( op ) );
  }
  return ops;
}

void database_fixture::validate_database()
{
  try
  {
    db->validate_invariants();
#ifdef HIVE_ENABLE_SMT
    db->validate_smt_invariants();
#endif
  }
  FC_LOG_AND_RETHROW();
}

void database_fixture::decline_voting_rights( const string& account, const bool decline, const fc::ecc::private_key& key )
{
  decline_voting_rights_operation op;
  op.account = account;
  op.decline = decline;

  push_transaction( op, key );
}

void database_fixture::proxy( account_name_type _account, account_name_type _proxy, const fc::ecc::private_key& _key )
{
  signed_transaction tx;
  account_witness_proxy_operation op;
  op.account = _account;
  op.proxy = _proxy;

  tx.operations.push_back( op );
  tx.set_expiration( db->head_block_time() + HIVE_MAX_TIME_UNTIL_EXPIRATION );
  push_transaction( tx, _key );
}

namespace test {

std::shared_ptr<full_block_type> _generate_block(hive::plugins::chain::abstract_block_producer& bp, const fc::time_point_sec _block_ts,
                                                 const hive::protocol::account_name_type& _wo, const fc::ecc::private_key& _key, uint32_t _skip)
{
  generate_block_flow_control generate_block_ctrl( _block_ts, _wo, _key, _skip );
  bp.generate_block( &generate_block_ctrl );
  return generate_block_ctrl.get_full_block();
}

bool _push_block(database& db, const block_header& header, 
                 const std::vector<std::shared_ptr<full_transaction_type>>& full_transactions, 
                 const fc::ecc::private_key& signer,
                 uint32_t skip_flags /* = 0 */)
{
  std::shared_ptr<full_block_type> full_block( hive::chain::full_block_type::create_from_block_header_and_transactions( header, full_transactions, &signer ) );
  existing_block_flow_control block_ctrl( full_block );
  return db.push_block( block_ctrl, skip_flags );
}

bool _push_block( database& db, const std::shared_ptr<full_block_type>& b, uint32_t skip_flags /* = 0 */ )
{
  existing_block_flow_control block_ctrl( b );
  return db.push_block( block_ctrl, skip_flags);
}

void _push_transaction( database& db, const signed_transaction& tx, const fc::ecc::private_key& key, uint32_t skip_flags,
  hive::protocol::pack_type pack_type, fc::ecc::canonical_signature_type _sig_type )
{ try {
  full_transaction_ptr _ftx = hive::chain::full_transaction_type::create_from_signed_transaction( tx, pack_type, false );

  if( key == fc::ecc::private_key() )
    _ftx->sign_transaction( std::vector<fc::ecc::private_key>(), db.get_chain_id(), _sig_type, pack_type );
  else
    _ftx->sign_transaction( std::vector<fc::ecc::private_key>{ key }, db.get_chain_id(), _sig_type, pack_type );
  db.push_transaction( _ftx, skip_flags );
} FC_CAPTURE_AND_RETHROW((tx)) }

} // hive::chain::test

namespace performance
{
  initial_data::initial_data( database_fixture* db, const std::string& _account ): account( _account )
  {
    key = db->generate_private_key( account );

    db->account_create( account, key.get_public_key(), db->generate_private_key( account + "_post" ).get_public_key() );
  }

  std::vector< initial_data > generate_accounts( database_fixture* db, int32_t number_accounts )
  {
    const std::string basic_name = "tester";

    std::vector< initial_data > res;

    for( int32_t i = 0; i< number_accounts; ++i  )
    {
      std::string name = basic_name + std::to_string( i );
      res.push_back( initial_data( db, name ) );

      if( ( i + 1 ) % 100 == 0 )
        db->generate_block();

      if( ( i + 1 ) % 1000 == 0 )
        ilog( "Created: ${accs} accounts",( "accs", i+1 ) );
    }

    db->validate_database();
    db->generate_block();

    return res;
  }

} // hive::chain::performance

} } // hive::chain
